// Variables
// -----------------------------------------------------------------------------
var NUM_POINTS = 100;

// Functions
// -----------------------------------------------------------------------------

function sine(amplitude, frequency, phase, t) {
	return amplitude * Math.sin(2 * Math.PI * frequency * t + phase);
}

// generate preset hills and valleys
function hillsAndValleys() {
	var min = -3;
	var max = 3;
	var range = Math.abs(max - min);
	var numPointsEdge = NUM_POINTS;
	var increment = range/numPointsEdge;
	var vertices = [];

	for (var i = 0; i < numPointsEdge; i++) {
		for (var j = 0; j < numPointsEdge; j ++) {

			// get point coordinates in plane's coordinate system
			// in the plane coordinate system we are using z as the height for the height map
			var x = min + increment * i;
			var y = min + increment * j;

			// get height map / z
			var z = 0;
			z += sine(0.2,1,0,x);
			z += sine(0.15,1,0.1,y);
			z += sine(0.1,0.75,0.2,x+y);
			z += sine(0.2,0.5,0.3,2 * x+y);
			z += sine(0.2,0.25,0.3,2 * x + 3 * y);

			vertices.push(new THREE.Vector3(x,y,z));
		}
	}

	return vertices;
}

// triangulate a list of vertices that is spread uniformly generated by hillsAndValleys()
function triangulateVertices(vertices) {

	var faces = []
	// hacky of generating triangles because I know how the points are split
	for (var i = 0; i < NUM_POINTS - 1; i ++) {
		for (var j = 0; j < NUM_POINTS - 1; j ++) {

			var index = i * NUM_POINTS + j;
			// counter clockwise order
			faces.push(new THREE.Face3(index,index + NUM_POINTS,index + 1));
			faces.push(new THREE.Face3(index + 1,index + NUM_POINTS,index + 1 + NUM_POINTS));
		}
	}

	return faces;
}



/**
INIT
Generate scene according to parameters et on the UI
// -----------------------------------------------------------------------------
**/
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight/2);
document.body.appendChild( renderer.domElement);

// axis helper
var axesHelper = new THREE.AxesHelper( 20 );
scene.add( axesHelper );

// White directional light at half intensity shining from the top.
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
directionalLight.position.set( 0, 0, 6);
scene.add( directionalLight );

// plane
var vertices = hillsAndValleys();
var faces = triangulateVertices(vertices);
var holes = [];
var triangles;
var geometry = new THREE.Geometry();
var material = new THREE.MeshPhongMaterial( 
	{
		color: 0xffffff,
		side: THREE.DoubleSide,
		emissive: new THREE.Color(0.01,0.01,0.01),
		specular: new THREE.Color(1,1,1),
		shininess: 10,
		flatShading: false,
		wireframe: false,
		wireframeLinewidth: 1,
	} 
);
geometry.vertices = vertices;
geometry.faces = faces;
var plane = new THREE.Mesh( geometry, material );
scene.add( plane );

plane.geometry.computeVertexNormals();

camera.position.z = 6;

// rotate plane
var rotate = function (x,y,z) {
	plane.rotation.x = x;
	plane.rotation.y = y;
	plane.rotation.z = z;
};
rotate(-0.3,0,0); // rotate 45 for now

function animate() {
	requestAnimationFrame( animate );
	renderer.render( scene, camera );

	// plane.rotation.x += 0.01;
	// plane.rotation.y += 0.01;
}
animate();

// UI
// -----------------------------------------------------------------------------

// Event Listeners
// -----------------------------------------------------------------------------
window.addEventListener( 'resize', onWindowResize, false );

// remember these initial values
// for window resize
var tanFOV = Math.tan( ( ( Math.PI / 180 ) * camera.fov / 2 ) );
var windowHeight = window.innerHeight;

function onWindowResize( event ) {

    camera.aspect = window.innerWidth / window.innerHeight;
    
    // adjust the FOV
    camera.fov = ( 360 / Math.PI ) * Math.atan( tanFOV * ( window.innerHeight / windowHeight ) );
    
    camera.updateProjectionMatrix();
    camera.lookAt( scene.position );

    renderer.setSize(window.innerWidth, window.innerHeight/2 );
    renderer.render( scene, camera );
}

